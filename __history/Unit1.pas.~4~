//By the FOX 3490
//fox3490@yandex.com
unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, OpenGL, DGLUT, Textures, Unit2;

const
VK_W = $57;
VK_S = $53;
VK_D = $44;
VK_A = $41;
VK_SHIFT = $10;
VK_SPACE = $20;
WORLDSIZE = 10;
GL_CLAMP_TO_EDGE =$812F;




type


   TVector = record  //Вектор
   X,Y,Z:GLfloat;
   end;


   TCamera = record
   Pos: Tvector;         //Позиция камеры
   PhiY: single;         //вертикальный улол поворота камеры
   PhiX: single;         //горизонтальный
   Speed: glFloat;       //Скорость камеры
   end;


  TForm1 = class(TForm)
    procedure FormCreate(Sender: TObject);
    procedure FormPaint(Sender: TObject);
    procedure FormResize(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;
  HRC : HGLRC;
  MouseMove1: boolean;
  glLightPos: array[0..3] of glFloat = (0,0,100,1);
  TempX1,TempY1,SingX,SingY,TempX2,TempY2 : integer;
  Point: Tpoint;


  Camera: TCamera;
  Eart, Glass, Brick, Tree, Cursor1, Flower,Road, Water, tree2,El, El2,F, Mel,Grass,BOT,Kr,Verx,W,S,D: Uint;
  map : array[1..120,1..120,1..100] of integer;
implementation

{$R *.dfm}

procedure glBindTexture(target: GLenum; texture: GLuint); stdcall; external opengl32;

// Процедура генирации карты
procedure mapcreate();
var i,j,l : integer;
begin
 for i := 10 to 80 do
   for j := 10 to 80 do
      for l := 1 to 1 do
      begin
        map[i,j,2] := 1;  ///////////////////
      end;











 for i := 1 to 5 do
   for j := 1 to 5 do
      for l := 2 to 5 do
      begin
        map[i,j,l] := 5;
      end;

  for i := 1 to 5 do
   for j := 1 to 5 do
      begin
        map[i,j,5] := 3;
      end;

  for i := 2 to 4 do
   for j := 2 to 4 do
      for l := 2 to 4 do
      begin
        map[i,j,l] := 0;
      end;

   map[3,5,2] := 0;
   map[3,5,3] := 0;

  for i := 2 to 4 do
   for j := 2 to 4 do
      begin
        map[i,j,1] := 3;
      end;

   map[3,5,1] := 3;

  for i := 1 to 100 do
   for j := 1 to 100 do
      begin
        map[i,j,1] := 4;
      end;

  map[6,9,2] := 2;
end;

procedure SetDCPixelFormat ( hdc : HDC );
 var
  pfd : TPixelFormatDescriptor;
  nPixelFormat : Integer;
 begin
  FillChar (pfd, SizeOf (pfd), 0);
  pfd.dwFlags  := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER;
   nPixelFormat := ChoosePixelFormat (hdc, @pfd);
  SetPixelFormat (hdc, nPixelFormat, @pfd);
 end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  mapcreate();//Создаем карту
  SetDCPixelFormat(Canvas.Handle);
  hrc := wglCreateContext(Canvas.Handle);
  wglMakeCurrent(Canvas.Handle, hrc);
  glEnable(GL_DEPTH_TEST); // включаем проверку разрешения фигур (впереди стоящая закрывает фигуру за ней)
  glDepthFunc(GL_LEQUAL);  //тип проверки
  glEnable(GL_TEXTURE_2D);   //Включаем режим нааложения текстур
  glEnable(GL_ALPHA_TEST);     //Разрешаем альфа тест (прозрачность текстур)
  glAlphaFunc(GL_GREATER,0.9);
  glEnable (GL_BLEND);         //Включаем режим смешивания цветов
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) ; //Тип смешивания
  glTexParameter (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); //Параметры наложения текстуры
  glTexParameter (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); //Параметры наложения текстуры


    LoadTexture('TEXTURES\skybox\back.bmp',Mel,false);
   LoadTexture('TEXTURES\skybox\top.bmp',Kr,false);
   LoadTexture('TEXTURES\skybox\front.bmp',Verx,false);
   LoadTexture('TEXTURES\skybox\left.bmp',W,false);
   LoadTexture('TEXTURES\skybox\right.bmp',S,false);
   LoadTexture('TEXTURES\skybox\bottom.bmp',D,false);











  LoadTexture('Tree.tga', Tree, false);
  LoadTexture('Water.tga', Water, false);
  LoadTexture('Tex.tga', Eart, false);
  LoadTexture('Glass.tga', Glass, false);
  LoadTexture('Brick.tga', Brick, false);
  LoadTexture('Cursor.tga', Cursor1, false);



  Camera.Pos.Z:=10;
  Camera.Pos.X:=50;
  Camera.Pos.Y:=50;
  Camera.PhiY:=-30;
  Camera.PhiX:=45;
  showCursor(false);
end;

procedure TForm1.FormPaint(Sender: TObject);
var i : integer;
    j : integer;
    l : integer;
begin
  FormResize(Sender); //процедура обновления

if GetAsyncKeyState(VK_ESCAPE)<>0 then Close;

////----------------КАМЕРА-------------------------------//
try                                                      //
if MouseMove1=false then                                 //
begin                                                    //
GetCursorPos(Point);                                     //
TempX1:=point.X;                                         //
TempY1:=point.Y;                                         //
MouseMove1:=true;                                        //
end;                                                     //
finally                                                  //
                                                         //
SetCursorPos(screen.Width div 2,screen.Height div 2);    //
GetCursorPos(Point) ;                                    //
 if MouseMove1=true then                                 //
  begin                                                  //
TempX2:=point.X;                                         //
TempY2:=point.Y;                                         //
SingX:=TempX1-TempX2;                                    //
SingY:=TempY1-TempY2;                                    //
if  (Camera.phiY<=90) and (Camera.phiY>=-90) then        //
 begin                                                   //
 Camera.phiY:=Camera.phiY+(-SingY/8);                    //
 end                                                     //
 else                                                    //
 begin                                                   //
   if Camera.phiY>=90 then                               //
  Camera.phiY:=90;                                       //
  if Camera.phiY<=-90 then                               //
  Camera.phiY:=-90;                                      //
  end;                                                   //
Camera.phiX:=Camera.phiX+(-SingX/4);                     //
TempX1:=0;                                               //
TempY1:=0;                                               //
TempX2:=0;                                               //
TempY2:=0;                                               //
SingX:=0;                                                //
SingY:=0;                                                //
MouseMove1:=false;                                       //
 end;                                                    //
end;                                                     //
///////////////////////////////////////////////////////////

if (GetAsyncKeyState(VK_W)<>0) or (GetAsyncKeyState(VK_S)<>0) or
    (GetAsyncKeyState(VK_D)<>0) or (GetAsyncKeyState(VK_A)<>0)  then
  begin
   Camera.Speed:=0.1; //Скорость камеры

if (GetAsyncKeyState(VK_W)<>0) then
   begin
    Camera.Pos.X:=Camera.Pos.X+Camera.Speed*cos((Camera.phiX+90)*Pi/180);
    Camera.Pos.Y:=Camera.Pos.Y+Camera.Speed*sin((Camera.phiX+90)*Pi/180);





   end;
     //Назад
   if (GetAsyncKeyState(VK_S)<>0) then
   begin
    Camera.Pos.X:=Camera.Pos.X+Camera.Speed*cos((Camera.phiX-90)*Pi/180);
    Camera.Pos.Y:=Camera.Pos.Y+Camera.Speed*sin((Camera.phiX-90)*Pi/180);
   end;
     //Вправо
   if (GetAsyncKeyState(VK_D)<>0) then
   begin
    Camera.Pos.X:=Camera.Pos.X+Camera.Speed*cos((Camera.phiX)*Pi/180);
    Camera.Pos.Y:=Camera.Pos.Y+Camera.Speed*sin((Camera.phiX)*Pi/180);
   end;
     //Влево
   if (GetAsyncKeyState(VK_A)<>0) then
   begin
    Camera.Pos.X:=Camera.Pos.X+Camera.Speed*cos((Camera.phiX+180)*Pi/180);
    Camera.Pos.Y:=Camera.Pos.Y+Camera.Speed*sin((Camera.phiX+180)*Pi/180);
   end;
  end;

  if (GetAsyncKeyState(VK_SHIFT)<>0) then   Camera.Pos.Z:=Camera.Pos.Z - Camera.Speed;

  if (GetAsyncKeyState(VK_SPACE)<>0) then   Camera.Pos.Z:=Camera.Pos.Z + Camera.Speed;

 glClearColor(0.43, 0.92, 0.97, 0.0); // цвет фона

 glClear (GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT); // очистка буфера цвета

glRotatef(-Camera.PhiY-90,1,0,0);
glRotatef(-Camera.PhiX,0,0,1);

//pисование
glTranslatef(-Camera.Pos.X,-Camera.Pos.Y,-Camera.Pos.Z);

for i := 1 to 40 do
for j := 1 to 40 do
for l := 1 to WORLDSIZE do
begin
glTranslatef(i * 1 * 2, j * 1 * 2, l * 1 * 2);
if map[i,j,l] = 1 then begin glBindTexture(GL_TEXTURE_2D,Eart); RenderBox(); end;
if map[i,j,l] = 2 then begin glBindTexture(GL_TEXTURE_2D,Glass); RenderBox(); end;
if map[i,j,l] = 3 then begin glBindTexture(GL_TEXTURE_2D,Tree); RenderBox(); end;
if map[i,j,l] = 4 then begin glBindTexture(GL_TEXTURE_2D,Water); RenderBox(); end;
if map[i,j,l] = 5 then begin glBindTexture(GL_TEXTURE_2D,Brick); RenderBox(); end;
glTranslatef(-i * 1 * 2, -j * 1 * 2, -l * 1 * 2);
end;




//--------------SkyBox---------------------------------------------------------------
  glBindTexture(GL_TEXTURE_2D,D);
glTranslatef(camera.pos.x ,camera.pos.y,camera.pos.z);renderSkyBox(500);
glBegin(GL_QUADS);
glEnd;
glTranslatef(-camera.pos.x,-camera.pos.y,-camera.pos.z);

  glBindTexture(GL_TEXTURE_2D,kr);
glTranslatef(camera.pos.x ,camera.pos.y,camera.pos.z);renderSkyBox2(500);
glBegin(GL_QUADS);
glEnd;
glTranslatef(-camera.pos.x,-camera.pos.y,-camera.pos.z);

  glBindTexture(GL_TEXTURE_2D,mel);
glTranslatef(camera.pos.X ,camera.pos.y,camera.pos.z);renderSkyBox3(500);
glBegin(GL_QUADS);
glEnd;
glTranslatef(-camera.pos.x,-camera.pos.y,-camera.pos.z);

  glBindTexture(GL_TEXTURE_2D,Verx);
glTranslatef(camera.pos.x ,camera.pos.y,camera.pos.z);renderSkyBox4(500);
glBegin(GL_QUADS);
glEnd;
glTranslatef(-camera.pos.x,-camera.pos.y,-camera.pos.z);

  glBindTexture(GL_TEXTURE_2D,W);
glTranslatef(camera.pos.x ,camera.pos.y,camera.pos.z);renderSkyBox5(500);
glBegin(GL_QUADS);
glEnd;
glTranslatef(-camera.pos.x,-camera.pos.y,-camera.pos.z);

  glBindTexture(GL_TEXTURE_2D,s);
glTranslatef(camera.pos.x ,camera.pos.y,camera.pos.z);renderSkyBox6(500);
glBegin(GL_QUADS);
glEnd;
glTranslatef(-camera.pos.x,-camera.pos.y,-camera.pos.z);






//будуший курсор:-)
{glTranslatef(Camera.Pos.X, Camera.Pos.Y - 20, Camera.Pos.Z);

glBindTexture(GL_TEXTURE_2D,Cursor1);
glBegin(GL_QUADS);
            glTexCoord2f(0, 0);   glVertex3f(-1, 1, -1);
            glTexCoord2f(1, 0);   glVertex3f(1,  1, -1);
            glTexCoord2f(1, 1);   glVertex3f(1,  1, 1);
            glTexCoord2f(0, 1);   glVertex3f(-1, 1, 1);
GLEnd;}
SwapBuffers(Canvas.Handle);
end;

//при изменении размера формы
procedure TForm1.FormResize(Sender: TObject);
begin
  glViewport(0, 0, ClientWidth, ClientHeight); //выделяем область куда будет выводиться наш буфер
  glMatrixMode ( GL_PROJECTION ); //переходим в матрицу проекции
  glLoadIdentity;  //сбрасываем текущую матрицу
  gluPerspective(50,ClientWidth/ClientHeight,1,1000); //Область видимости
  glMatrixMode ( GL_MODELVIEW ); //переходим в модельную матрицу
  glLoadIdentity;//сбрасываем текущую матрицу
  InvalidateRect ( Handle,nil,False );  //перерисовка формы
end;

procedure TForm1.FormClose(Sender: TObject; var Action: TCloseAction);
begin
showCursor(true);
end;

end.
